3.给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度。

```说明
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

- 思路

  需要最长的，所以不能排序，考虑滑动窗口即双指针。起始两指针在0，右指针每次移动更新数据直到出现重复元素[2]，左指针移到重复元素[1]的下一个。

- 步骤

  - **初始化两个指针**：这两个指针代表滑动窗口的左右边界，开始时都指向字符串的第一个字符。我们称左指针为`left`，右指针为`right`。
  - **使用一个哈希集合HASHMAP** 来存储当前窗口内出现的字符与对应位置，以便快速判断新加入的字符是否已经存在于窗口中。
  - **移动右指针扩展窗口**：从字符串的开始处逐个向后移动`right`指针，并将对应的字符添加到集合中。如果当前字符不在集合中，则将其添加进去；如果已经在集合中了，说明遇到了重复字符。
  - **更新最大长度**：每当遇到重复字符之前，都需要计算当前窗口的大小(`right - left`)，并尝试更新结果（即最大长度）。注意，因为我们是从索引0开始的，所以实际的子串长度需要加1。
  - **处理重复字符**：当发现重复字符时，开始移动`left`指针以缩小窗口，直到窗口中不再包含重复字符为止。

  ```java
  HashMap<Character, Integer> map =  new HashMap<>();
  // HashMap，键是字符，值是字符上次出现的位置索引
   int left = 0, right = 0, maxlength = 0;
   while(right < s.length()){
      char temp = s.charAt(right);
      if(map.containsKey(temp)){
       // 如果当前字符已经在map中，更新left指针到重复字符的下一个位置
       // 注意要确保left只向前移动
  	left = Math.max(left, map.get(temp)+1);
      }
      // 更新当前字符的位置
      map.put(temp,right);
      // 计算最大长度
      maxlength = Math.max(maxlength, right - left + 1);
      //移动指针
      right ++;
   }
   return maxlength;
  ```

  - A.chatAt(B)：返回A指定索引B处的字符
  - A.get(B)：返回A指定字符键B处的值
  - A.put(B,C)：把B做键，C做值存入Map中



438.给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

```说明
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

- 思路

  需要比较字符及其频率，而不是它们的顺序，可以使用滑动窗口技术和哈希表来追踪当前窗口内的字符频率，并与 `p` 的字符频率进行比较。

- 实现

  - 创建两个哈希表：一个用于记录 `p` 中每个字符的出现次数 (`pCount`)，另一个用于记录当前窗口中每个字符的出现次数 (`window`)。
  - 使用 `right` 指针遍历字符串 `s`，将(`pCount`)中存在的字符加入到 `window` 哈希表中。
  - 当某个字符在 `window` 中的数量超过 `pCount` 中的数量时，移动 `left` 指针缩小窗口，**直到**窗口中的该字符数量满足条件。
  - 当某字符不存在于`pCount`时，left跳到right前一个。
  - 当窗口大小等于 `p` 的长度，记录下此时 `left` 指针的位置作为结果之一。
  - 继续移动 `right` 指针直到遍历完整个字符串 `s`。

  ```java
     int slen = s.length(), plen = p.length(), left = 0, right = 0;
      // 创建两个哈希表，一个用于记录p中字符的频率(pCount)，另一个用于当前窗口中的字符频率(window)
      HashMap<Character, Integer> window = new HashMap<>();
      HashMap<Character, Integer> pCount = new HashMap<>();
      List<Integer> result = new ArrayList<>();
      // 初始化pCount哈希表，记录p中每个字符出现的次数
      for(int i = 0 ; i < plen; i++){
          char c = p.charAt(i);
          pCount.put(c, pCount.getOrDefault(c, 0) + 1);
      }
      while(right < slen) {
          char cright = s.charAt(right);
          if(pCount.containsKey(cright)){
              // 将当前字符加入到window哈希表中，并增加其计数
              window.put(cright, window.getOrDefault(cright, 0) + 1 );       
              // 如果当前字符在window中的数量超过了在p中的数量，移动left指针缩小窗口
              while(window.get(cright) > pCount.get(cright)){
                  char tLeft = s.charAt(left);
                  if(window.containsKey(tLeft)){
                      window.put(tLeft, window.getOrDefault(tLeft, 0) - 1);
                  }
                  left ++; 
              }
          } else {
              window.clear();
              left = right + 1;
          }
          if(right - left + 1 == plen){
              // 添加当前窗口的起始索引到结果列表
              result.add(left);
              // 准备移动窗口，从window中移除left指针所指向的字符，并减少其计数
              window.put(s.charAt(left), window.getOrDefault(s.charAt(left), 0) - 1);
              left ++; 
          }
          right ++;
      }
      return result; 
  ```

  - A.getOrDefault(B, 0)：查找B键的值，有则返回对应值；无则返回"0"
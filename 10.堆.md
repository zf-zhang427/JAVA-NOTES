

#### **1. 堆的基本概念**

##### **(1) 定义**

- 堆是一种特殊的完全二叉树，满足以下性质：
  - **最大堆：每个节点的值都大于或等于其子节点的值。
  - **最小堆：每个节点的值都小于或等于其子节点的值。
- 堆通常用数组实现，因为完全二叉树非常适合数组存储。

##### **(2) 堆的特点**

- **完全二叉树**：除了最后一层外，其他层的节点都被完全填满，且最后一层的节点从左到右连续排列。
- **堆顶元素**：最大堆的堆顶是最大值，最小堆的堆顶是最小值。
- 父子节点关系：
  - 对于数组中的索引：`i`
    - 父节点索引：`(i - 1) / 2`
    - 左子节点索引：`2 * i + 1`
    - 右子节点索引：`2 * i + 2`

#### **2. 基本操作**

##### **(1) 插入元素**

- 将新元素插入到堆的末尾（数组的最后一个位置）。
- **上浮：**比较新插入的元素与其父节点，如果不满足堆的性质，则交换它们的位置，直到满足堆的性质。

##### **(2) 删除堆顶元素**

- 将堆顶元素（最大值或最小值）移除，并用堆的最后一个元素替换堆顶。
- **下沉**：比较新堆顶与其子节点，如果不满足堆的性质，则交换它们的位置，直到满足堆的性质。

##### **(3) 构建堆**

- 给定一个无序数组，将其转换为堆。
- 从最后一个非叶子节点开始，依次对每个节点执行“下沉”操作。

#### **3.PriorityQueue 的功能**

##### **(1) 基本特性**

- 无序存储，有序访问：
  - `PriorityQueue` 内部并不保证元素的存储顺序，但它会根据优先级动态调整，确保每次取出的元素是优先级最高的。
- 默认是最小堆：
  - 默认情况下，`PriorityQueue` 是一个**最小堆**，即**队列中的最小值具有最高优先级，因此每次取出的是最小值**。

##### (2) 底层实现原理

`PriorityQueue` 的底层实现是一个 **二叉堆**，通常是一个完全二叉树，使用数组来存储元素。具体来说：

- **插入操作**：将新元素插入到堆的末尾，并通过“上浮”操作将其调整到正确的位置。
- **删除操作**：移除堆顶元素，并将最后一个元素移到堆顶，然后通过“下沉”操作将其调整到正确的位置。

##### (3) 常用方法

1. 添加元素： `offer(E e)`    将指定元素**插入**队列 (**注意并非插入头或尾**)，不会抛出异常。

2. 移除元素：`E poll()`    **移除**并**返回**队列中的头元素（优先级最高的元素）。如果队列为空，则返回 `null`。

3. 查看元素：`E peek()`    **返回**队列中的头元素，但**不移除**它。如果队列为空，则返回 `null`。

4. `int size()`    返回队列中**元素的数量**。

5. `boolean isEmpty()`    判断队列**是否为空**。如果队列为空，则返回 true，否则返回 false。

6. `void clear()`    **清空**队列中的所有元素。

7. `boolean contains(Object o)`    判断队列中**是否包含指定的元素**。包含则返回 `true`，否则 `false`。

8. 自定义比较器：

   ```java
   PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(
           (a, b) -> a.getValue() - b.getValue()
   );
   ```

   注意`Map.Entry`表示键值对，表示对输入的键值对进行自定义比较

   PS:PriorityQueue动态扩容，所以不用初始化大小



#### 215.给定整数数组 `nums` 和整数 `k`，请**返回数组中第 k 个最大的元素**。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。你必须设计并实现时间复杂度为 O(n)的算法解决此问题。

```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

- 思路

  用PriorityQueue优先队列，其内部维护一个完全二叉树，对存入的数据进行编排，**永远输出树中最小元素**，利用这一特性，创建k个元素的队列，存入数组前k个元素后对后续元素进行判断，如果**比树顶元素大则替换**(内部会自动再编排)，遍历后树存储数组最大的k个数，数顶是第k个最大数

- 步骤

  - 使用优先队列（PriorityQueue）创建一个最小堆。
  - 将数组的前 `k` 个元素加入堆中。

  - 遍历剩余的元素：
    - 对于数组中的每个新元素，如果它比堆顶元素大，则将其替换到堆中，并调整堆。
    - 如果它比堆顶元素小，则忽略它。
  - 遍历结束后，堆中保存的就是数组中最大的 `k` 个元素。

```java
    public int findKthLargest(int[] nums, int k) {
        // 创建一个大小为 k 的最小堆（优先队列）
        PriorityQueue<Integer> minHeap = new PriorityQueue<>(k);
        for (int i = 0; i < k; i++) {
            minHeap.offer(nums[i]);
        }
        // 遍历剩余元素
        for (int i = k; i < nums.length; i++) {
            // 如果当前元素比堆顶元素大，则替换堆顶元素
            if (nums[i] > minHeap.peek()) {
                minHeap.poll(); // 移除堆顶元素
                minHeap.offer(nums[i]); // 插入新元素
            }
        }
        // 堆顶元素是第 k 个最大的元素
        return minHeap.peek();
    }
```



#### 347.给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中`出现频率前 k 高的元素`。你可以按 **任意顺序** 返回答案。

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

- 思路

  用hashmap存数据<数据，频率>，重写priorityQueue的排序器，实现最小堆排序，容器内数量大于k时，移除顶元素，遍历完后剩下出现频率前k高的元素。

- 实现

  1. **统计频率**：
     - 使用一个哈希表 `frequencyMap` 来记录每个元素的出现次数。
     - 遍历数组 `nums`，对于每个元素 `num`，更新其在 `frequencyMap` 中的计数。
  2. **构建最小堆**：
     - 创建一个大小为 `k` 的最小堆（优先队列），用于存储频率最高的 k 个元素。
     - 遍历`frequencyMap`中的所有键值对：
       - 直接将当前元素加入堆中。
       - 堆的大小达到`k`，则移除堆顶元素。

  ```java
      public int[] topKFrequent(int[] nums, int k) {
          // Step 1: 统计频率
          Map<Integer, Integer> countFreq = new HashMap<>();
          for (int num : nums) {
              countFreq.put(num, countFreq.getOrDefault(num, 0) + 1);
          }
          // Step 2: 构建最小堆
          PriorityQueue<Map.Entry<Integer, Integer>> storeFreq = new PriorityQueue<>((a, b) -> a.getValue() - b.getValue());
          for (Map.Entry<Integer, Integer> storeNum : countFreq.entrySet()) {
              storeFreq.offer(storeNum);
              if (storeFreq.size() > k) {
                  storeFreq.poll();
              }
          }
          // Step 3: 提取结果
          int[] result = new int[k];
          for (int i = 0; i < k; i++) {
              result[i] = storeFreq.poll().getKey();
          }
          return result;
      }
  ```

  - PriorityQueue<Map.Entry<Integer, Integer>> storeFreq = new PriorityQueue<>((a, b) -> a.getValue() - b.getValue());

    用到了lambda，在初始化的括号内可以重定义排序器

  - Map<>与Map.Entry<>

    - Map是**键值对的集合**，Map.Entry<>是**键值对**，所以要存储键值对类型的数据用Map.Entry<>

  - entrySet()

    - 当你遍历 `Map` 时，实际上是在遍历它的键值对集合，而不是单独的键或值。因此，`Map` 提供了一个方法 `entrySet()` 来获取这些键值对的集合。

  - 所以在强化for中：表示获取集合`frequencyMap`**所有键值对**并遍历输入给**键值对属性元素** `entry`

    ```java
    for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet())
    ```

  - 注意：`storeFreq.poll().getKey()`后size会改变，所以不要`i < storeFreq.size();`



#### 面试题：返回未排序数组中的最小k个数（不能全排序）

- 思路

  很简单，把所有元素装进priorityQueue中即可，要k个则提取k个

  ```java
  public static void sortMin(int[] nums, int k) {
      PriorityQueue<Integer> sortMQ = new PriorityQueue<Integer>();
      for(int i  = 0; i < nums.length; i ++){
          sortMQ.offer(nums[i]);
      }
      System.out.println("最小前" + k + "个是：");
      for(int i = 0; i < k; i ++){
          System.out.println(sortMQ.poll());
      }
  }
  ```

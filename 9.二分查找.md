#### 二分查找

- **概念：**每次都将查找范围缩小一半，从而在对数时间内找到目标值。

- **基本步骤**

  - **初始化边界**：设定两个指针，`left` 和 `right`，分别指向数组的起始位置和结束位置。
  - **计算中间点：**计算 `left` 和 `right` 的中间点 `mid = left + (right - left) / 2`。
  - **比较**
    -  `array[mid] == target`，返回索引 `mid`。
    -  `array[mid] < target`，说明目标值在右半部分，则更新 `left = mid + 1`。
    -  `array[mid] > target`，说明目标值在左半部分，则更新 `right = mid - 1`。

- **注意点**

  - 计算中间点使用 `left + (right - left) / 2` 而不是 `(left + right) / 2` 是为了避免整型溢出

    `int` 类型是 32 位有符号整数，`left + right`有溢出风险
  
  

#### 35.给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

```说明
输入: nums = [1,3,5,6], target = 5
输出: 2
```

- 思路

  基础点最上方有讲，需要注意的是`返回它将会被按顺序插入的位置`。指向的是第一个满足 `nums[i] =< target`，所以循环外返回`left`。

  ```java
          if(nums.length == 0 || nums == null )
          return 0;
          int left = 0, right = nums.length - 1;
          int mid = 0;
          while(left <= right){
               mid = left + (right - left)/2;
              if(nums[mid] == target)
              return mid;
              else if(nums[mid] < target)
              left = mid + 1;// 目标值在右半部分
              else if(nums[mid] > target)
              right = mid - 1;// 目标值在左半部分
          }
  		// 如果没有找到目标值，left 就是应该插入的位置
          return left ;
  ```



#### 74.给你一个满足下述两条属性的 `m x n` 整数矩阵：1.每行中的整数从左到右按非严格递增顺序排列。2.每行的第一个整数大于前一行的最后一个整数。给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

```说明
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
```

- 思路

  和上一题差不多，需要注意的是如何将得到的mid值转为横纵坐标

  ```java
  public boolean searchMatrix(int[][] matrix, int target) {
      // 检查矩阵是否为空
      if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
          return false;
      int xMax = matrix[0].length; // 横坐标(组内元素个数)
      int yMax = matrix.length;    // 纵坐标(有多少组)
      int left = 0, right = xMax * yMax - 1; 
      while (left <= right) {
          int mid = left + (right - left) / 2; 
          int midY = mid / xMax; // 计算中间点所在的行
          int midX = mid % xMax; // 计算中间点所在的列
          if (matrix[midY][midX] == target) {
              return true; 
          } else if (matrix[midY][midX] < target) {
              left = mid + 1; // 目标值在右半部分
          } else {
              right = mid - 1; // 目标值在左半部分
          }
      }
  	return false; // 如果循环结束仍未找到目标值，返回 false
  }
  ```
  #### 34.给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 `target`，返回 `[-1, -1]`。你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。
  
  ```说明
  输入：nums = [5,7,7,8,8,10], target = 8
  输出：[3,4]
  ```

- 思路

  用两次二分查找，一次查找目标开始位置，另一次查找目标结束位置。

  在二分查找过程中，`if (nums[mid] >= target)   right = mid - 1;`优先处理right，当条件成立right会逼近left，所以最终返回目标开始位置；

  `if (nums[mid] <= target)   left = mid + 1;`优先处理left，当条件成立left会逼近right，所以最终返回目标结束位置；

  ```java
      public int[] searchRange(int[] nums, int target) {
          int[] result = new int[]{-1, -1};
          // 查找开始位置
          int start = findFirst(nums, target);
          // 如果开始位置无效，直接返回 [-1, -1]
          if (start == -1) {
              return result;
          }
          // 查找结束位置
          int end = findLast(nums, target);
          result[0] = start;
          result[1] = end;
          return result;
      }
      // 查找目标值的开始位置
      private int findFirst(int[] nums, int target) {
          int left = 0, right = nums.length - 1;
          while (left <= right) {
              int mid = left + (right - left) / 2;
              if (nums[mid] >= target) {
                  right = mid - 1; 
              } else {
                  left = mid + 1; 
              }
          }
          // 检查 left 是否越界以及是否等于目标值
          if (left < nums.length && nums[left] == target) {
              return left;
          }
          return -1;
      }
      // 查找目标值的结束位置
      private int findLast(int[] nums, int target) {
          int left = 0, right = nums.length - 1;
          while (left <= right) {
              int mid = left + (right - left) / 2;
              if (nums[mid] <= target) {
                  left = mid + 1; 
              } else {
                  right = mid - 1; 
              }
          }
          // 检查 right 是否越界以及是否等于目标值
          if (right >= 0 && nums[right] == target) {
              return right;
          }
          return -1;
      }
  }
  ```

  

#### 33.整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。在传递给函数之前，`nums` 在预先未知的某个下标 `k`上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

```说明
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

- 思路

  首先数组分为：

  - 左半部分：从旋转点到数组末尾(4...7)
  - 右半部分：从数组开头到旋转点之前(0...2)

  依旧用二分查找解题。需要考虑：

  - target是在左部分还是右部分
  - mid是在左部分还是右部分
  - 以left作为基点，大于nums[left]说明在左部分，否则在右部分
  - 如果在同一个部分，则继续搜索，反之mid换到另一部分

- 实现

```java
    public int search(int[] nums, int target) {
        if(nums == null || nums.length == 0)
        return -1;
        int left = 0, right = nums.length - 1;
        while(left <= right){
            int mid = left + (right - left)/2;
            if(nums[mid] == target)
            return mid;
            // 判断 mid 是在左半部分还是右半部分
            if (nums[mid] >= nums[left]) {
                if (target >= nums[left] && target < nums[mid]) {
                    // 目标值在左半部分且小于mid范围内
                    right = mid - 1;
                } else {
                    // 目标值在右半部分
                    left = mid + 1;
                }
            } else {// mid 在右半部分
                if (target > nums[mid] && target <= nums[right]) {
                    // 目标值在右半部分的范围内且大于mid范围内
                    left = mid + 1;
                } else {
                    // 目标值在左半部分
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
```



#### 153.已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

#### 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`

#### 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

#### 注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

- 思路

  - 如果 x > nums[n−1]，那么可以推出以下结论：

    - nums 一定被分成左右两个递增段；
    - 第一段的所有元素均大于第二段的所有元素；
    - x 在第一段。
    - 最小值在第二段。

    所以 x 一定在最小值的左边。

  - 如果 x <= nums[n−1]，那么 x 一定在第二段。x 要么是最小值，要么在最小值右边。

- 实现

  ```java
      public int findMin(int[] nums) {
          int left = 0, right = nums.length - 1;
          while(left <= right){
              int mid = left + (right - left)/2;
              if(nums[mid] <= nums[nums.length - 1]){
                  right = mid - 1;
              }else{
                  left = mid + 1;
              }
          }
          return nums[left];
      }
  ```

  

​				 


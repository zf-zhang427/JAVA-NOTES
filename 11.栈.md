#### 栈的基本概念

- **定义：**栈是一种**只能在一端进行插入或删除操作**的线性表。

- **特点**

  - 后进先出：**最后入栈的元素最先出栈**。
  - 插入和删除操作都发生在栈顶（Top）。

- **实现**

  - 基于Deque实现：双端队列接口，允许在队列的两端进行插入和删除操作。它既可以实现队列，也可以实现栈。

- **主要操作**

  - `push(e)`：将元素压入栈顶（等价于 `offerFirst(e)`）。
  - `pop()`：移除并返回栈顶元素（等价于 `pollFirst()`）。
  - `peek()`：返回栈顶元素但不移除。
  - `isEmpty()`：判断栈是否为空。
  - `size()`：返回栈中元素的数量。

- 应用场景

  - 括号匹配
    - 实现思路：遇到左括号时压入栈，遇到右括号时检查栈顶是否匹配。

  - 延迟处理
  
    - 我们需要**不断比较当前元素与之前未处理的元素**，而栈可以帮助我们动态地维护这些未处理的元素
  
  - 回溯算法
    - 在解决路径搜索问题（如迷宫问题、八皇后问题）时，通常会使用栈来保存当前的路径状态，并在**需要时回退**。
  
  - 撤销操作
    
    撤销机制(回溯机制)
    
    - 延迟用程序（如文本编辑器）中的**撤销**功能可以通过栈实现。
    - 示例：每次操作压入栈中，撤销时弹出栈顶操作。



#### 20.给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。有效字符串需满足：1.左括号必须用相同类型的右括号闭合。2.左括号必须以正确的顺序闭合。3.每个右括号都有一个对应的相同类型的左括号。

```java
输入：s = "(]"
输出：false
```

- 思路：

  用队列模拟栈，遇到左括号则压栈，遇到右括号则弹出并匹配，

  需要考虑的问题是1.右括号多了：poll返回空时会与char类型不匹配，所以需要在弹出前判断内部长度。

  ​			       2.左括号多了：最后返回时判断内部长度。

- 实现

  1. 初始化空队列。
  2. 遍历字符串中的每个字符：
     - 如果是左括号，压入栈中。
     - 如果是右括号：
       - 检查栈是否为空。如果为空，返回 `false`。
       - 弹出栈顶元素，并检查是否与当前右括号匹配。如果不匹配，返回 `false`。
  3. 遍历结束后，检查栈是否为空：
     - 如果栈为空，返回 `true`（所有括号匹配）。
     - 如果栈不为空，返回 `false`（存在未匹配的左括号）。

  ```java
      public boolean isValid(String s) {
          Deque<Character> stack = new ArrayDeque<Character>();
          char[] chars = s.toCharArray();
          char temp = ' ';
          for(char ch : chars){
              if (ch == '(' || ch == '{' || ch == '[') {
                  // 左括号直接入栈
                  stack.offerFirst(ch);
              } else {
                  // 右括号需要匹配栈顶元素
                  if (stack.isEmpty()) {
                      return false; // 栈为空，无法匹配
                  }
                  // 弹出栈顶元素
                  char top = stack.pollFirst();
                  // 判断括号是否匹配
                  if ((ch == ')' && top != '(') ||
                      (ch == '}' && top != '{') ||
                      (ch == ']' && top != '[')) {
                      return false; // 不匹配
                      }
              }
          }
          return stack.isEmpty();
      }
  ```

  - 注意：在队列Deuqe中，offer是从队尾插入，所以本题用offerFirst；poll是从对头取出，所以默认即可
  - string转char数组：`char[] chars = s.toCharArray()`;   也可以用`s.charAt(i)`，遍历下标存入数组

#### 155.设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。实现 `MinStack` 类:   `MinStack()` 初始化堆栈对象。   `void push(int val)` 将元素val推入堆栈。   `void pop()` 删除堆栈顶部的元素。   `int top()` 获取堆栈顶部的元素。   `int getMin()` 获取堆栈中的最小元素。（很少考）

- 思路：

  定义一个Deque<int[]>队列存储数组，num[0]存当前元素，num[i]存最小值，初始化时自定义一个元素以进行后续操作

  ```java
      private final Deque<int[]> stack = new ArrayDeque<>();
      public MinStack() {
          stack.offerFirst(new int[]{Integer.MAX_VALUE, Integer.MAX_VALUE});
      }
      public void push(int val) {
          stack.offerFirst(new int[]{val, Math.min(getMin(), val)});
      }
      public void pop() {
          stack.poll();
      }
      public int top() {
          return stack.peek()[0];
      }
      public int getMin() {
          return stack.peek()[1];
      }
  ```

  - 初始化中：new int[] ()：`()`存处对象属性(重写方法，大小等)；new int[]{}：`{}`存对象内容



#### 394.给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

- 思路

  - 核心：
    - 使用两个队列分别存储重复次数和当前正在构建的字符串。
    - 每次遇到左括号 `[` 时，将当前的状态（重复次数和字符串）压入队列中，并重置状态以处理新的子结构。
    - 每次遇到右括号 `]` 时，从队列中弹出之前保存的状态，并根据重复次数生成新的字符串。
  - 双端队列的作用：
    - `countDeque`：用于存储每个 `[` 前的数字（重复次数）。
    - `stringDeque`：用于存储每个 `[` 前的字符串。
  - 字符处理逻辑：
    - 数字：累积数字以计算重复次数。
    - 左括号 `[`：将当前的重复次数和字符串压入队列，并重置状态。
    - 右括号 `]`：从队列中弹出之前的状态，并根据重复次数生成新的字符串。
    - 普通字符：直接追加到当前正在构建的字符串中。
  - 最终结果：
    - 当遍历完所有字符后，`currentString` 中存储的就是解码后的结果。

  ```java
      public String decodeString(String s) {
          Deque<Integer> countDeque = new ArrayDeque<>();
          Deque<String> stringDeque = new ArrayDeque<>();
          String currentString = "";
          int count = 0;
          for(char ch : s.toCharArray()){
              if(ch >= '0' && ch <= '9'){
                  count = count *10 + ch - '0';
          }else if( ch == '['){
              countDeque.offerFirst(count);
              stringDeque.offerFirst(currentString);
              count = 0;
              currentString = "";
          }else if( ch == ']'){
              String temp = stringDeque.pollFirst();
              int repeatTime = countDeque.pollFirst();
              for(int i = 0; i < repeatTime; i ++){
                  temp += currentString;
              }
              currentString = temp;
          }else{
              currentString += ch;
          }
          }
          return currentString;
      }
  ```



#### 739.给定一个整数数组 `temperatures` ，表示**每天的温度**，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

- 思路

  当前值需要与之前未处理的元素交互，所以具有延迟性，可以使用栈，栈顶大时，压入栈；栈顶小时，弹出交互，下一个继续直至栈顶大。

- 实现

  - 初始化

    - 创建空栈 `stack`，存储数组中**元素的索引**。
    - 创建结果数组 `answer`，初始值全部为 `0`（找不到更高的温度，结果默认为 `0`）。

  - 遍历数组：

    - 对于当前元素temperatures[i]：
      - 检查栈顶元素对应温度是否小于当前温度temperatures[i]：
        - 如果是，则说明**找到了栈顶元素对应天数**的下一个更高温度。
        - 弹出栈顶元素的索引 `num`，并计算天数差：`answer[num] = i - num;`。
        - 继续检查新的栈顶元素，直到栈为空或者**栈顶元素对应的温度大于等于当前温度**。
      - 将当前索引 `i` 压入栈中。

    ```java
        public int[] dailyTemperatures(int[] temperatures) {
            int[] answer = new int[temperatures.length];
            Deque<Integer> stack = new ArrayDeque<>();
            for(int i = 0; i < temperatures.length; i++){
                int temp = temperatures[i];
                while(!stack.isEmpty() && temperatures[stack.peek()] < temp){
                    int num = stack.pollFirst();
                    answer[num] = i - num;
                }
            stack.offerFirst(i);
            }
            return answer;
        }
    ```

    - int[] answer = new int[]：初始化数组后内容全是0
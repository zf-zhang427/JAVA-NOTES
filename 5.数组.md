#### 53.给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```说明
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

- **思路**

  两个变量，`currentMax` 和 `globalMax`。`currentMax` 用来记录当前子数组的和，而`globalMax` 则用于跟踪目前为止的最大子数组和。

  开始将这两个变量都初始化为数组的第一个元素。

  `currentMax`添加元素规则， *nums*[*i*] 左边的子数组元素和是负的，就不用和左边的子数组拼在一起了。(严谨是前面数和+当前数 < 当前数)

- **实现**

​	从数组的第二个元素开始，依次遍历每个元素，对每个元素执行以下步骤：

​	a. 更新 `currentMax`。对数组中的每一个元素，选择将其加入到现有的子数组中（即加上当前元素），或者单独作为一个新的子数组的起点（即仅包含当前元素）。为决定哪一种方式能获得更大的和，比较 `currentMax + 当前元素` 和 `当前元素` 的值，选择较大的一个作为新的 `currentMax`。

​	b. 如果 `currentMax` 大于 `globalMax`，则更新 `globalMax` 为 `currentMax` 的值。确保 `globalMax` 始终保存着所遇到的最大子数组和。

```java
        int currentMax = nums[0], globalMax = nums[0];
        int i;
        for(i = 1; i < nums.length; i ++){
            currentMax = Math.max(currentMax + nums[i], nums[i]);

            if(globalMax < currentMax){
                globalMax = currentMax;
            }
        }
        return globalMax;
```



#### 189.给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

```说明
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

- **注意**

  k可能大于长度本身，可以通过取余来获取有效移动

- **思路**

  三次翻转法适用于解决**数组元素的旋转问题**，尤其是需要高效地将一个数组中的**元素向左或向右轮转指定的位置**时。第一次翻转**所有元素**，第二次翻转**前k个元素**，第三次翻转**剩余元素**。

- **实现**

  1. **计算实际旋转次数**：
     - 考虑当 `k` 大于数组长度时的情况。如果将数组旋转其长度的整数倍次，结果会与原数组相同。因此实际需要旋转的次数是 `k % nums.length`。
  2. **整体反转数组**：
     - 将整个数组进行反转（例如，对于数组 `[1,2,3,4,5,6,7]` 变为 `[7,6,5,4,3,2,1]`）。使得原本前面的元素现在位于数组的后半部分，后面的元素则位于前半部分，但局部顺序都是反的。
  3. **反转前 k 个元素**：
     - 反转数组的前 `k` 个元素（在上面的例子中，如果 `k = 3`，则反转前 3 个元素，得到 `[5,6,7,4,3,2,1]`），将原本位于数组末尾的 `k` 个元素放到了正确的位置，并且顺序也恢复正常。
  4. **反转剩余的元素**：
     - 反转从第 `k` 个元素开始到数组末尾的所有元素（继续上面的例子，反转剩下的部分，即 `[5,6,7,1,2,3,4]`），使它们回到正确的顺序。

  ```java
  {		int n = nums.length;
          k %= n; // 处理k大于数组长度的情况
          // 反转整个数组
          reverse(nums, 0, n - 1);
          // 反转前k个元素
          reverse(nums, 0, k - 1);
          // 反转剩余的元素
          reverse(nums, k, n - 1);
  }
      private static void reverse(int[] nums, int start, int end) {
          while (start < end) {
              // 交换nums[start]和nums[end]
              int temp = nums[start];
              nums[start] = nums[end];
              nums[end] = temp;
              start++;
              end--;
          }
      }
  ```

  

#### 56.以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

```说明
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

- **思路**

  首先根据区间的起始位置进行排序。确保所有可能重叠的区间在列表中是相邻的，简化了后续的合并逻辑。
  遍历排序后的区间列表，检查每个区间是否与前一个区间重叠。如果不重叠，则将当前区间直接添加到结果集合中；如果重叠，则合并这两个区间，更新前一个区间的结束位置为两者结束位置的最大值。

- **实现**

  - **排序**：根据区间的起始位置进行排序。如果两个区间的起始位置相同，则根据结束位置排序。确保只需比较相邻的区间即可发现合并的情况。
  - **初始化**：创建一个结果列表 `result` 用于存放集合，并将第一个区间作为初始的当前比较区间 `current_interval`。
  - **遍历和合并**：从第二个区间开始遍历整个区间数组：

    - 如果当前区间与 `current_interval` 有重叠（即当前区间的起始位置小于或等于 `current_interval` 的结束位置），则需要合并这两个区间。合并的方式是更新 `current_interval` 的结束位置为两者结束位置的最大值。
  - 如果没有重叠，则将 `current_interval` 添加到结果列表中，并将当前区间设置为新的 `current_interval`。
  
  ```java
  public static int[][] merge(int[][] intervals) {
  
      if (intervals.length <= 1)
          return intervals;
      // 按照每个区间的起始位置进行排序
      Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
  
      List<int[]> merged = new ArrayList<>();
      int[] currentInterval = intervals[0];
      merged.add(currentInterval);
      for (int[] interval : intervals) {
          // 如果不重叠
          if (interval[0] > currentInterval[1]) {
              currentInterval = interval;
              merged.add(currentInterval);
          } else {
              // 存在重叠，更新merged中最后一个区间的结束位置为两者结束位置的最大值
              currentInterval[1] = Math.max(currentInterval[1], interval[1]);
          }
      }
      // 将结果转换为二维数组并返回
      return merged.toArray(new int[merged.size()][]);
  }
  ```
  
  -  `Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));`  是Lambda表达式，具体是遍历元素
    - compare `return o1-o2`:升序排列    `return o2-o1`:降序排列
  
  ```java
          Arrays.sort(intervals, new java.util.Comparator<int[]>() {
              @Override
              public int compare(int[] a, int[] b) {
                  return Integer.compare(a[0], b[0]);
              }
          });
  ```
  
  - 引用与赋值
    - **`currentInterval`** 是一个引用变量，直接修改**`currentInterval`**的数组会使它指向 `merged` 列表中元素变化。
    - 当执行 `currentInterval = interval;` 时，实际上是让 `currentInterval` 指向一个新的对象，而不是修改原来指向的对象的内容。这意味着原来的引用关系被切断了，`currentInterval` 不再指向 `merged` 列表中的最后一个元素，而是指向了一个新的区间对象。
  - `merged.toArray(new int[merged.size()][]);` 
    - 将一个 `List<int[]>` 类型的集合转换为一个二维数组 (`int[][]`)。(前[]:数组内有几个子数组，后[]:子数组内有几个元素)
    - `toArray(T[] a)`指定返回数组的类型和大小。



#### 238.给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。题目数据 保证 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。

```说明
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

- **思路**

  通过计算每个元素的前缀乘积和后缀乘积，然后将这两个乘积相乘来得到最终结果。时间复杂度是 O(n)，比嵌套循环强O(n^2)

- **实现**

  - **前缀乘积**：计算每个元素左边所有元素的乘积。

  - **后缀乘积**：计算每个元素右边所有元素的乘积。

  - **合并结果**：对于每个位置 `i`，其结果等于该位置的前缀乘积与后缀乘积的乘积。

  ```java
  public int[] productExceptSelf(int[] nums) {
      int n = nums.length;
      // Step 1: 左边元素
      int[] pre = new int[n];
      pre[0] = 1; // 初始化第一个元素的前缀乘积为1，因为没有左侧元素
      for (int i = 1; i < n; i++) {
          pre[i] = pre[i - 1] * nums[i - 1]; // 当前位置的前缀乘积等于前一个位置的前缀乘积乘以前一个位置的数值
      }
      // Step 2: 右边元素
      int[] suf = new int[n];
      suf[n - 1] = 1; // 初始化最后一个元素的后缀乘积为1，因为没有右侧元素
      for (int i = n - 2; i >= 0; i--) {
          suf[i] = suf[i + 1] * nums[i + 1]; // 当前位置的后缀乘积等于下一个位置的后缀乘积乘以下一个位置的数值
      }
      // Step 3: 对应左右相乘
      int[] ans = new int[n];
      for (int i = 0; i < n; i++) {
          ans[i] = pre[i] * suf[i]; // 每个位置的结果是该位置的前缀乘积与后缀乘积的乘积
      }
      return ans;
  }
  ```



#### 41.给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

```说明
输入：nums = [3,4,-1,1]
输出：2
解释：1 在数组中，但 2 没有。
```

- **自己的方法**

  - 思路：先排序，对数组遍历，小于0的跳过，如果当前值大于上一个值+1，返回上一个值+1，否则要么相等要么连续，继承继续遍历

  ```java
      Arrays.sort(nums);
      int temp = 0;
      for(int num:nums){
          if(num<=0)
          continue;
          if(num>temp + 1)
          return temp + 1;
          else{
              temp = num;
          }
      }
      return temp + 1;
  ```

  - 战胜22%的对手。。。

- **优化方法**

  - 思路：将每个正整数放到它对应的索引位置上，即数字`1`应该放在索引`0`的位置，数字`2`放在索引`1`的位。。。通过遍历数组快速找到第一个不符合这个规则的位置，从而确定缺失的最小正整数。

  - 实现思路

    - 循环放置元素：外层`for`循环遍历整个数组。使用`while`循环尝试将其放置在正确的位置上
      - 确保当前处理的是正数。
      - 确保该数落在搜索范围内（1到n）。
      - 确保目标位置还没有正确的值（避免无限循环）。
    - 交换函数：当发现一个数不在它应有的位置时，调用`swap`函数将其与目标位置的数交换。
    - 查找缺失的正整数：第二个`for`循环用于检查数组中是否有任何数没有在其应有的位置上。一旦发现第一个这样的数（即`nums[i] != i + 1`），就返回`i + 1`作为结果。如果所有数都在正确的位置上，则返回`len + 1`，表示缺失的最小正整数是`len + 1`。

    ```java
          public int firstMissingPositive(int[] nums) {
    		int len = nums.length;
            for (int i = 0; i < len; i++) {
                while (nums[i] > 0 && nums[i] <= len && nums[nums[i] - 1] != nums[i]) {
                    // 满足在指定范围内、并且没有放在正确的位置上，才交换
                    // 例如：数值 3 应该放在索引 2 的位置上
                    swap(nums, nums[i] - 1, i);
                }
            }
            for (int i = 0; i < len; i++) {
                if (nums[i] != i + 1) {
                    return i + 1;
                }
            }
            return len + 1;
        }
        private void swap(int[] nums, int index1, int index2) {
            int temp = nums[index1];
            nums[index1] = nums[index2];
            nums[index2] = temp;
        }
    ```

    - 注意：使用while是因为 第一轮只是将 `i`换到属于它的位置，下一轮是把接收到的数换到属于它的位置，以此循环直到不满足条件

- 方法比较

  第一种方法最损耗性能可能就是排序，排序上来就是损耗O(nlogn)
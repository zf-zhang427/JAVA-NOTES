560.给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。子数组是数组中元素的连续非空序列。

```说明
输入：nums = [1,1,1], k = 2
输出：2
```

- 思路：

  要查某一圈的元素和等于k，首先不能排序，因为不排除[...x,0,0]，前面满足条件下，接下来两个0的组合也满足，同时要考虑0,0.....x满足的情况，子串将成倍增长，所以创建哈希表，装（前数和，出现次数）当遇到非零值时，相应次数都是1，当出现0或负数时，次数才会大于1。因此，无论是正数、负数还是0，只要前缀和之差等于 `k`，就能找到符合条件的子数组。

- 实现步骤

  - 初始化：

    - 创建一个哈希表 `prefixSumCount` 并添加 `(0, 1)`，表示前缀和为 `0` 出现了一次。
    - 初始化 `currentSum = 0` 和 `count = 0`。

  - 遍历数组：

    - 对于数组中的每一个元素，更新 `currentSum += num`。
    - 检查 `prefixSumCount` 是否包含键 `currentSum - k`。如果存在，则将对应的值加到 `count` 上，因为这意味着存在若干个以当前元素结尾且和为 `k` 的子数组。
    - 更新哈希表中当前前缀和 `currentSum` 的出现次数。

    ```java
    int count = 0, sum = 0, i = 0; 
            Map<Integer,Integer> items = new HashMap<>();
            items.put(0,1);
            while(i < nums.length){
                sum += nums[i];
                if(items.containsKey(sum - k)){
                    count += items.get(sum - k);
                }
                items.put(sum, items.getOrDefault(sum, 0) + 1);
                i ++;
            }
            return count;
    ```

    - length()用于求String字符串对象的长度，而length用于求String字符串数组的长度。



239.给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

```说明
                                            解释：
                                            滑动窗口的位置                最大值
                                            ---------------               -----
                                            [1  3  -1] -3  5  3  6  7       3
                                             1 [3  -1  -3] 5  3  6  7       3
                                             1  3 [-1  -3  5] 3  6  7       5
                                             1  3  -1 [-3  5  3] 6  7       5
                                             1  3  -1  -3 [5  3  6] 7       6
                                             1  3  -1  -3  5 [3  6  7]      7
```

- 思路：

  双端队列可以在两端进行插入和删除操作，非常适合解决滑动窗口最大值的问题

  - 用于存储数组元素的**索引**的队列
  - 在遍历内进行四步操作(不是实现顺序)：
    - 从最后存放值
    - 从开头筛选超过范围的值(开头最早放入)
    - 从后往前与当前值比较，大的留下，小的舍弃
    - 将开头的坐标赋给结果数组
  - 队列最后从早到晚，从大到小

- 具体代码：

  ```java
  public int[] maxSlidingWindow(int[] nums, int k) {
  		 // 检查输入有效性
          if (nums == null || k <= 0) {
              throw new IllegalArgumentException("无效输入");
          }
          int n = nums.length;
          if (n * k == 0) return new int[0];
          if (k == 1) return Arrays.copyOf(nums, n);
  
          // 初始化双端队列和结果数组
          Deque<Integer> deque = new LinkedList<>();
          int[] result = new int[n - k + 1];
  
          for (int i = 0; i < n; i++) {
              // 移除不在当前窗口范围内的索引（即那些索引小于i-k+1的元素）
              while (!deque.isEmpty() && deque.peekFirst() <= i - k) {
                  deque.pollFirst();
              }
              // 移除所有比当前元素小的元素的索引，因为它们不可能成为任何后续窗口的最大值
              while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                  deque.pollLast();
              }
              // 将当前元素的索引添加到双端队列的末尾
              deque.offerLast(i);
              // 当遍历到第k-1个元素时开始记录结果，保证每次都是完整的窗口大小
              if (i >= k - 1) {
                  // 双端队列的第一个元素是当前窗口的最大值的索引
                  result[i - k + 1] = nums[deque.peekFirst()];
              }
          }
          return result;
  ```

  - Deque<Integer> deque = new **LinkedList**<>();

  1. **添加元素**：**off**
     - `addFirst(e)` 或 `offerFirst(e)`：将元素`e`添加到队列的开头。
     - `addLast(e)` 或 `offerLast(e)`：将元素`e`添加到队列的末尾。
  2. **移除元素**：**poll**
     - `removeFirst()` 或 `pollFirst()`：移除并返回队列的第一个元素。如果队列为空，`removeFirst()`抛出异常，而`pollFirst()`返回`null`。
     - `removeLast()` 或 `pollLast()`：移除并返回队列的最后一个元素。类似地，`removeLast()`在队列为空时抛出异常，`pollLast()`则返回`null`。
  3. **获取元素**：**peek**
     - `getFirst()` 或 `peekFirst()`：返回但不移除队列的第一个元素。如果队列为空，`getFirst()`抛出异常，`peekFirst()`返回`null`。
     - `getLast()` 或 `peekLast()`：返回但不移除队列的最后一个元素。同样，`getLast()`在队列为空时抛出异常，`peekLast()`返回`null`。

Z

76. 最小覆盖子串

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

```说明
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

- 思路：

  1. - 使用两个哈希表来分别记录 `t` 中每个字符及其频率（称为 `dictT`），以及当前窗口中每个字符及其频率（称为 `windowCounts`）。
     - 确定需要匹配的不同字符种类数 `required`（即 `dictT` 的大小）。
     - 维护一个计数器 `formed` 来记录当前窗口中有多少种字符满足了 `t` 中对应字符的频率要求。
  2. - 使用两个指针 `left` 和 `right` 来表示当前窗口的边界。初始时，两个指针都指向字符串 `s` 的起始位置。
     - 扩展右指针 `right` 来扩大窗口，并更新 `windowCounts`。
     - 每当窗口内的某个字符频率达到了 `t` 中该字符的需求量时，增加 `formed` 计数。
     - 当所有字符都满足条件时，尝试通过移动左指针 `left` 来缩小窗口，同时保持窗口仍然符合条件，以找到更小的有效子串。

  ```java
  public String minWindow(String s, String t) {
          // 输入检查：如果s或t为空或者s的长度小于t，则直接返回空字符串
          if (s == null || t == null || s.length() < t.length()) {
              return "";
          }
          // 创建一个哈希表dictT来存储字符串t中每个字符及其出现次数
          Map<Character, Integer> dictT = new HashMap<>();
          for (char c : t.toCharArray()) {
              int count = dictT.getOrDefault(c, 0);
              dictT.put(c, count + 1);
          }
          // required变量表示需要匹配的不同字符的数量（即dictT的大小）
          int required = dictT.size();
          // formed变量表示当前窗口中满足条件的字符种类数
          int formed = 0;
          // 创建一个哈希表windowCounts来动态记录当前窗口中每个字符及其出现次数
          Map<Character, Integer> windowCounts = new HashMap<>();
          // 初始化左右指针left和right，以及结果数组ans
          int left = 0, right = 0;
          int[] ans = {-1, 0, 0}; // length, start, end
          // 开始遍历字符串s
          while (right < s.length()) {
              // 获取当前右指针指向的字符，并更新窗口中的字符计数
              char c = s.charAt(right);
              int count = windowCounts.getOrDefault(c, 0);
              windowCounts.put(c, count + 1);
              // 如果当前字符在dictT中，并且其数量正好等于dictT中该字符的数量，则formed加一
              if (dictT.containsKey(c) && windowCounts.get(c).equals(dictT.get(c))) {
                  formed++;
              }
              // 当所有字符都满足条件时，尝试缩小窗口以找到更小的有效子串
              while (left <= right && formed == required) {
                  c = s.charAt(left); // 获取当前左指针指向的字符                
                  // 更新最小子串信息
                  if (ans[0] == -1 || right - left + 1 < ans[0]) {
                      ans[0] = right - left + 1; // 子串长度
                      ans[1] = left; // 子串起始位置
                      ans[2] = right; // 子串结束位置
                  }
                 // 移动左指针以尝试缩小窗口，并更新窗口内的字符计数
                  windowCounts.put(c, windowCounts.get(c) - 1);        
                  // 如果当前字符是关键字符，并且其数量不再满足要求，则减少formed计数
                  if (dictT.containsKey(c) && windowCounts.get(c) < dictT.get(c)) {
                      formed--;
                  }
                  left++; // 缩小窗口
              }
              right++; // 扩大窗口
          }
          // 返回找到的最小子串，如果没有找到符合条件的子串，则返回空字符串
          return ans[0] == -1 ? "" : s.substring(ans[1], ans[2] + 1);
  }
  ```

  - intValue()：把Integer转换成int。
  - substring(int begin, int end)：提取的字符串包括 `begin` 位置的字符，但不包括 `end`位置的字符。
  - dictT.size()：返回dictT中键值对的数量。
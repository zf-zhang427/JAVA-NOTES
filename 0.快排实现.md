- **选择基准值：**
  通常可以选择数组的第一个元素、最后一个元素、中间元素或随机选择一个元素作为基准值。

- **分区：**

  - 将数组中的元素按照与基准值的大小关系分成两部分：

    - 左边部分：所有小于基准值的元素。
    - 右边部分：所有大于基准值的元素。

    基准值最终会被放置在正确的位置上。

- **递归排序：**

  对左边部分和右边部分分别递归调用快速排序。
  当子数组的长度为 0 或 1 时，直接返回（递归终止条件）。

- 合并结果：

  由于分区操作已经将数组划分并排序，因此无需显式合并。

```java
// 主方法：调用快速排序
public static void quickSort(int[] arr, int left, int right) {
    if (left < right) {
        // 分区操作，返回基准值的正确位置
        int pivotIndex = partition(arr, left, right);
        // 对左半部分递归排序
        quickSort(arr, left, pivotIndex - 1);
        // 对右半部分递归排序
        quickSort(arr, pivotIndex + 1, right);
    }
}
// 分区函数：将数组划分为两部分，并返回基准值的正确位置
private static int partition(int[] arr, int left, int right) {
    // 选择最右侧的元素作为基准值
    int pivot = arr[right];
    int i = left - 1; // i 指向小于 pivot 的最后一个元素
    for (int j = left; j < right; j++) {
        // 如果当前元素小于等于基准值
        if (arr[j] <= pivot) {
            i++; // 扩大小于 pivot 的区域
            swap(arr, i, j); // 交换元素
        }
    }
    // 将基准值放到正确的位置
    swap(arr, i + 1, right);
    // 返回基准值的索引
    return i + 1;
}
// 辅助方法：交换数组中的两个元素
private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

